217. Contains Duplicate
    def containsDuplicate(self, nums):
        seen = set()
        for dig in nums:
            if dig in seen:
                return True
            else:
                seen.add(dig)
        
        return False

Time Complexity: O(n)
Explanation: Using a set, we can avoid creating a double for loop by storing digits that have not been seen or returning true if a duplicate was found.

242. Valid Anagram
    def isAnagram(self, s, t):
        sdict = {}
        for char in s:
            if char in sdict:
                sdict[char] += 1
            else:
                sdict[char] = 1
        
        tdict = {}
        for char in t:
            if char in tdict:
                tdict[char] += 1
            else:
                tdict[char] = 1
        
        return sdict == tdict
Time Complexity: O(n)
Explanation: Using a dictionary, we store the characters and their counts for s and t. Then comparing the dictionaries to see if they are anagrams.

1. Two Sum
    def twoSum(self, nums, target):
        numdict = {}
        for idx, i in enumerate(nums):
            remain = target - i
            if remain in numdict:
                return [numdict[remain], idx]
            numdict[i] = idx
Time Complexity: O(n)
Explanation: Using a dictionary, we store the remainder of each value and search of the remainder of a certain value exists in the list.

49. Group Anagrams
    def groupAnagrams(self, strs):
        bigdict = defaultdict(list)
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            bigdict[tuple(count)].append(s)  

        return bigdict.values()
Time Complexity: O(n^2)
Explanation: Using a dictionary, we are storing a tuple is basically a list of the 26 characters and their count as the key and the words that correspond to that count as the value. We are finding these values using their ascii.

347.     def topKFrequent(self, nums, k):
        import heapq

        seen = {}
        for dig in nums:
            if dig in seen:
                seen[dig] += 1
            else:
                seen[dig] = 1

        max_heap = []
        for key, value in seen.items():
            heapq.heappush(max_heap, (-value, key))
        
        top_k = []
        for _ in range(k):
            if max_heap:
                negative_value, key = heapq.heappop(max_heap)
                top_k.append(key)
        
        return top_k
Time Complexity:
Explanation:
