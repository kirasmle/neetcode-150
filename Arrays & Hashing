217. Contains Duplicate
    def containsDuplicate(self, nums):
        seen = set()
        for dig in nums:
            if dig in seen:
                return True
            else:
                seen.add(dig)
        
        return False

Time Complexity: O(n)
Explanation: Using a set, we can avoid creating a double for loop by storing digits that have not been seen or returning true if a duplicate was found.

242. Valid Anagram
    def isAnagram(self, s, t):
        sdict = {}
        for char in s:
            if char in sdict:
                sdict[char] += 1
            else:
                sdict[char] = 1
        
        tdict = {}
        for char in t:
            if char in tdict:
                tdict[char] += 1
            else:
                tdict[char] = 1
        
        return sdict == tdict
Time Complexity: O(n)
Explanation: Using a dictionary, we store the characters and their counts for s and t. Then comparing the dictionaries to see if they are anagrams.

1. Two Sum
    def twoSum(self, nums, target):
        numdict = {}
        for idx, i in enumerate(nums):
            remain = target - i
            if remain in numdict:
                return [numdict[remain], idx]
            numdict[i] = idx
Time Complexity: O(n)
Explanation: Using a dictionary, we store the remainder of each value and search of the remainder of a certain value exists in the list.

49. Group Anagrams
    def groupAnagrams(self, strs):
        bigdict = defaultdict(list)
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            bigdict[tuple(count)].append(s)  

        return bigdict.values()
Time Complexity: O(n^2)
Explanation: Using a dictionary, we are storing a tuple is basically a list of the 26 characters and their count as the key and the words that correspond to that count as the value. We are finding these values using their ascii.

347.     def topKFrequent(self, nums, k):
        import heapq

        seen = {}
        for dig in nums:
            if dig in seen:
                seen[dig] += 1
            else:
                seen[dig] = 1

        max_heap = []
        for key, value in seen.items():
            heapq.heappush(max_heap, (-value, key))
        
        top_k = []
        for _ in range(k):
            if max_heap:
                negative_value, key = heapq.heappop(max_heap)
                top_k.append(key)
        
        return top_k
Time Complexity: O(nlogn)
Explanation: Using a max heap, we will store the values of the number and the count for which it occurs as a tuple. Now iterating through k, we will pop off the top k values from the max heap.

271. Encode and Decode String
not available with leetcode basic plan:(

238. Product of Array Except Self
    def productExceptSelf(self, nums):
        prefix = [1] * len(nums)
        prefix[1] = nums[0]
        for i in range(2, len(nums)):
            prefix[i] = prefix[i - 1] * nums[i - 1]
        
        suffix = [1] * len(nums)
        suffix[len(nums) - 2] = nums[len(nums) - 1]
        for i in range(len(nums) - 3, -1, -1):
            suffix[i] = suffix[i + 1] * nums[i + 1]
        
        res = [0] * len(nums)
        for i in range(len(nums)):
            res[i] = prefix[i] * suffix[i]

        return res
Time Complexity: O(n)
Explanation: Create a prefix and suffix array of the product sum then multiply the two for the answer.

36. Valid Sudoku
    def isValidSudoku(self, board):
        rows = defaultdict(set)
        cols = defaultdict(set)
        unit = defaultdict(set)

        for r in range(9):
            for c in range(9):
                if board[r][c] == '.': continue
                if (board[r][c] in rows[r] or
                   board[r][c] in cols[c] or
                   board[r][c] in unit[(r // 3, c // 3)]):
                   return False
                rows[r].add(board[r][c])
                cols[c].add(board[r][c])
                unit[(r // 3, c // 3)].add(board[r][c])

        return True   
Time Complexity: O(n^2)
Explanation: Create a set to keep track of the digits that are in each row, column, and square unit. Iterate through the sudoku board, if the tile is blank skip, else if a number is repeated in the same row, column, or square unit return false, else add that value to the respect row, column, and square unit (r // 3, c // 3).

128. Longest Consecutive Sequence
    def longestConsecutive(self, nums):
        if not nums: return 0
        nums.sort()
        temp = 1
        res = 1
        for i in range(1,len(nums)):
            if nums[i] == nums[i - 1] + 1:
                temp += 1
            elif nums[i] == nums[i - 1]:
                continue
            else:
                res = max(temp, res)
                temp = 1
        
        return max(res, temp)
Time Complexity: O(nlogn)
Explanation: Iterate through the sorted array and use greedy to keep the longest consecutive seq.


