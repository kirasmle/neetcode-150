217. Contains Duplicate
    def containsDuplicate(self, nums):
        seen = set()
        for dig in nums:
            if dig in seen:
                return True
            else:
                seen.add(dig)
        
        return False

Time Complexity: O(n)
Explanation: Using a set, we can avoid creating a double for loop by storing digits that have not been seen or returning true if a duplicate was found.

242. Valid Anagram
    def isAnagram(self, s, t):
        sdict = {}
        for char in s:
            if char in sdict:
                sdict[char] += 1
            else:
                sdict[char] = 1
        
        tdict = {}
        for char in t:
            if char in tdict:
                tdict[char] += 1
            else:
                tdict[char] = 1
        
        return sdict == tdict
Time Complexity: O(n)
Explanation: Using a dictionary, we store the characters and their counts for s and t. Then comparing the dictionaries to see if they are anagrams.

1. Two Sum
    def twoSum(self, nums, target):
        numdict = {}
        for idx, i in enumerate(nums):
            remain = target - i
            if remain in numdict:
                return [numdict[remain], idx]
            numdict[i] = idx
Time Complexity: O(n)
Explanation: Using a dictionary, we store the remainder of each value and search of the remainder of a certain value exists in the list.

49. Group Anagrams
    def groupAnagrams(self, strs):
        bigdict = defaultdict(list)
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            bigdict[tuple(count)].append(s)  

        return bigdict.values()
Time Complexity:
Explanation:
