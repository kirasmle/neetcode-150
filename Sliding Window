121. Best Time to Buy and Sell Stock
    def maxProfit(self, prices):
        buy = 0
        profit = 0
        minbuy = prices[buy]
        for i in range(1, len(prices)):
            minbuy = min(minbuy, prices[buy])
            profit = max(profit, prices[i] - minbuy)
            buy += 1
        return profit
Time Complexity: O(n)
Explanation: Iterating through the array starting at the first element, keep track of the minimum buy value with i being the current sell value. Keep the max profit.

3. Longest Substring Without Repeating Characters
    def lengthOfLongestSubstring(self, s):
        seen = set()
        length = 0
        l = 0
        for r in range(len(s)):
            while s[r] in seen:
                seen.remove(s[l])
                l += 1
            seen.add(s[r])
            length = max(length, r - l + 1)

        return length
Time Complexity: O(n)
Explanation: By keeping track of the seen characters in a set, we create a left and right pointer, iterating with the right. If we've seen the value at r before, remove l from the set and inc l to shorten the window. Add unseen r values to the set and keep the max length.

424. Longest Repeating Character Replacement
    def characterReplacement(self, s, k):
        count = {}
        res = 0
        l = 0
        maxf = 0
        for r in range(len(s)):
            count[s[r]] = 1 + count.get(s[r], 0)
            maxf = max(maxf, count[s[r]])
            while (r - l + 1) - maxf > k:
                count[s[l]] -= 1
                l += 1
            res = max(res, r - l + 1)

        return res
Time Complexity: O(n)
Explanation: Using a dynamic window, we keep track of the frequency of each occuring char and store the char with the max frequency, to ensure our window does not surpass k replacements, we inc the left when the window length - the freq of the max char exceeds k. Finally, we always store the max window length.

567. Permutation in String
    def checkInclusion(self, s1, s2):
        s1dict = {}
        for i in range(len(s1)):
            s1dict[s1[i]] = 1 + s1dict.get(s1[i], 0)
        l = 0
        for r in range(len(s1) - 1, len(s2)):
            tempdict = {}
            for j in range(l, r + 1):
                tempdict[s2[j]] = 1 + tempdict.get(s2[j], 0) 
            if tempdict == s1dict:
                return True
            tempdict.clear()
            l += 1
        return False
Time Complexity: O(m * n)
Explanation: Create a dictionary storing the chars and freqs of the first string and iterate through the second on a fixed window size, recomputing a dictionary each time and comparing to the s1dict. This is a brute force and inefficient solution, revisit later.
