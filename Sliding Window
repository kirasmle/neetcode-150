121. Best Time to Buy and Sell Stock
    def maxProfit(self, prices):
        buy = 0
        profit = 0
        minbuy = prices[buy]
        for i in range(1, len(prices)):
            minbuy = min(minbuy, prices[buy])
            profit = max(profit, prices[i] - minbuy)
            buy += 1
        return profit
Time Complexity: O(n)
Explanation: Iterating through the array starting at the first element, keep track of the minimum buy value with i being the current sell value. Keep the max profit.

3. Longest Substring Without Repeating Characters
    def lengthOfLongestSubstring(self, s):
        seen = set()
        length = 0
        l = 0
        for r in range(len(s)):
            while s[r] in seen:
                seen.remove(s[l])
                l += 1
            seen.add(s[r])
            length = max(length, r - l + 1)

        return length
Time Complexity: O(n)
Explanation: By keeping track of the seen characters in a set, we create a left and right pointer, iterating with the right. If we've seen the value at r before, remove l from the set and inc l to shorten the window. Add unseen r values to the set and keep the max length.

424. Longest Repeating Character Replacement
    def characterReplacement(self, s, k):
        count = {}
        res = 0
        l = 0
        maxf = 0
        for r in range(len(s)):
            count[s[r]] = 1 + count.get(s[r], 0)
            maxf = max(maxf, count[s[r]])
            while (r - l + 1) - maxf > k:
                count[s[l]] -= 1
                l += 1
            res = max(res, r - l + 1)

        return res
Time Complexity: O(n)
Explanation: Using a dynamic window, we keep track of the frequency of each occuring char and store the char with the max frequency, to ensure our window does not surpass k replacements, we inc the left when the window length - the freq of the max char exceeds k. Finally, we always store the max window length.
