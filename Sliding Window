121. Best Time to Buy and Sell Stock
    def maxProfit(self, prices):
        buy = 0
        profit = 0
        minbuy = prices[buy]
        for i in range(1, len(prices)):
            minbuy = min(minbuy, prices[buy])
            profit = max(profit, prices[i] - minbuy)
            buy += 1
        return profit
Time Complexity: O(n)
Explanation: Iterating through the array starting at the first element, keep track of the minimum buy value with i being the current sell value. Keep the max profit.

3. Longest Substring Without Repeating Characters
    def lengthOfLongestSubstring(self, s):
        seen = set()
        length = 0
        l = 0
        for r in range(len(s)):
            while s[r] in seen:
                seen.remove(s[l])
                l += 1
            seen.add(s[r])
            length = max(length, r - l + 1)

        return length
Time Complexity: O(n)
Explanation: By keeping track of the seen characters in a set, we create a left and right pointer, iterating with the right. If we've seen the value at r before, remove l from the set and inc l to shorten the window. Add unseen r values to the set and keep the max length.

424. Longest Repeating Character Replacement
    def characterReplacement(self, s, k):
        count = {}
        res = 0
        l = 0
        maxf = 0
        for r in range(len(s)):
            count[s[r]] = 1 + count.get(s[r], 0)
            maxf = max(maxf, count[s[r]])
            while (r - l + 1) - maxf > k:
                count[s[l]] -= 1
                l += 1
            res = max(res, r - l + 1)

        return res
Time Complexity: O(n)
Explanation: Using a dynamic window, we keep track of the frequency of each occuring char and store the char with the max frequency, to ensure our window does not surpass k replacements, we inc the left when the window length - the freq of the max char exceeds k. Finally, we always store the max window length.

567. Permutation in String
    def checkInclusion(self, s1, s2):
        s1dict = {}
        for i in range(len(s1)):
            s1dict[s1[i]] = 1 + s1dict.get(s1[i], 0)
        l = 0
        for r in range(len(s1) - 1, len(s2)):
            tempdict = {}
            for j in range(l, r + 1):
                tempdict[s2[j]] = 1 + tempdict.get(s2[j], 0) 
            if tempdict == s1dict:
                return True
            tempdict.clear()
            l += 1
        return False
Time Complexity: O(m * n)
Explanation: Create a dictionary storing the chars and freqs of the first string and iterate through the second on a fixed window size, recomputing a dictionary each time and comparing to the s1dict. This is a brute force and inefficient solution, revisit later.

76. Minimum Window Substring
    def minWindow(self, s, t):
        if t == "":
            return ""
        reslen = float("inf")
        res = [-1,-1]
        countT, window = {}, {}
        for c in t:
            countT[c] = 1 + countT.get(c, 0)
        have = 0
        need = len(countT)
        l = 0
        for r in range(len(s)):
            c = s[r]
            window[c] = 1 + window.get(c, 0)
            if c in countT and window[c] == countT[c]:
                have += 1
            while have == need:
                if (r - l + 1) < reslen:
                    res = [l, r]
                    reslen = r - l + 1
                window[s[l]] -= 1
                if s[l] in countT and window[s[l]] < countT[s[l]]:
                    have -= 1
                l += 1
        l, r = res
        return s[l:r+1] if reslen != float("inf") else ""
Time Complexity: O(n)
Explanation: using a dynamic window, hashmap, and int of have and need, keep track of how many letters in the current substring meet the need in string t. while all conditions are met, keep increasing the left pointer to get the smallest window.

239. Sliding Window Maximum
    def maxSlidingWindow(self, nums, k):
        res = []
        l = 0
        r = 0
        deq = deque()

        while r < len(nums):
            while deq and nums[deq[-1]] < nums[r]:
                deq.pop()
            deq.append(r)
            if l > deq[0]:
                deq.popleft()
            if (r + 1) >= k:
                res.append(nums[deq[0]])
                l += 1
            r += 1

        return res
Time Complexity: O(n)
Explanation: This solution uses a monotonic dequeue to track the max at each window. The deq stores the indices of each element where the first element will always be the max of the window. With the right pointer, smaller elements of the deq are removed and the current r is added to the deq. With the left pointer, left indices are popped if we are past that window. Once the full first window is formed, the value at the beginning of the deq is appened to res.
